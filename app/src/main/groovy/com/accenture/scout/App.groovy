/*
 * This Groovy source file was generated by the Gradle 'init' task.
 */
package com.accenture.scout

import java.text.SimpleDateFormat
import java.util.logging.Logger
import java.util.logging.Level
import groovy.io.FileType
import groovy.time.TimeCategory
import groovy.time.TimeDuration

import java.util.regex.Matcher
import java.util.regex.Pattern

import static groovyx.gpars.GParsPool.withPool
class App {
    static Logger logger = Logger.getLogger(App.getClass().getName())
    def baseDirPath
    def logsPath
    def search
    def replace



    List replaceInFiles(){
        def results = []
        def baseDir
        try {
            baseDir = new File(baseDirPath)
            //find all files in deep directory structure

            baseDir.eachFileRecurse(FileType.FILES) {
                // dont touch buckup file
                if(!it.name.endsWith(".bck")) {

                    // Matcher
                    def dest = (it.text =~ search)
                    if(dest.find()) {
                        def copy = new File(it.parent, it.name +".bck")
                        copy.text = ""
                        copy << it.text
                        def replacement = dest.replaceAll(replace)
                        it.text = ""
                        it << replacement
                    }
                     results.add("path: ${it.absolutePath} numbers of findings ${dest.count} \n")
                }else{
                    results.add("path: ${it.absolutePath} not touching backup file \n")
                }
            }
        }catch(Exception e){
            logger.log(Level.SEVERE, e.getMessage(), e)
        }
        return results
    }

    List replaceInFilesParallel(){
        def baseDir
        //find all files in deep directory structure
        def files = []
        def results = []
        try {
         baseDir = new File(baseDirPath)
        baseDir.eachFileRecurse(FileType.FILES) {
            item -> files << item
        }
            results = withPool{
                files.collectParallel {
                    if(!it.name.endsWith(".bck")) {

                        // Matcher
                        def dest = (it.text =~ search)
                        if(dest.find()) {
                            def copy = new File(it.parent, it.name + ".bck")
                            copy.text = ""
                            copy << it.text
                            def replacement = dest.replaceAll(replace)
                            it.text = ""
                            it << replacement
                        }
                             "path: ${it.absolutePath} numbers of findings ${dest.count} \n"
                    }else{
                          "path: ${it.absolutePath} not touching backup file \n"
                    }
                }
            }
        }catch(Exception e){
            logger.log(Level.SEVERE, e.getMessage(), e)
        }


        return results
    }


    static void main(String[] args) {
        if(args == null || args.size() < 3 ){
            println "please define baseDir, search text, replace text and optionally path for output file"
            return;
        }

        //setup parameters
        def timeStart = new Date()
        def SimpleDateFormat format = new SimpleDateFormat('yyyy-MM-dd')
        def dft = format.format(timeStart)
        def app = new App()
        app.baseDirPath = args[0]

        app.search = args[1]
        app.replace = args[2]
        if(args.size() == 4){
            app.logsPath = args[3]
        }



        def results = app.replaceInFilesParallel()
        def timeStop = new Date()
        TimeDuration duration = TimeCategory.minus(timeStop, timeStart)
        def resultsFile

        try {
            if(app.logsPath != null){
                resultsFile = new File("${app.logsPath}/results-${dft}.log")
            }else{
                resultsFile = new File("${app.baseDirPath}/results-${dft}.log")
            }
             resultsFile.append("start time:  ${timeStart} stop time: ${timeStop} duration: ${duration} \n")
             resultsFile.append(results)
             resultsFile.append("\n")
        }catch(Exception e){
            logger.log(Level.SEVERE, e.getMessage(), e)
        }
    }
}
